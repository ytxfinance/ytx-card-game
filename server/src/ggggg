const { state, dispatch } = useContext(store)
const [attackingCardId, setAttackingCardId] = useState(0)
const [isAttackMode, setIsAttackMode] = useState(false)

useEffect(() => {
    const enemyHand =
        state.playerNumber === 1
            ? state.game.player2.hand.map(index => (
                    <div className='card' key={index + Math.random()}></div>
                ))
            : state.game.player1.hand.map(index => (
                    <div className='card' key={index + Math.random()}></div>
                ))
    const allyHand = displayHandCards(state.playerNumber === 1 ? state.game.player1.hand : state.game.player2.hand)

    dispatch({
        type: 'SET_HAND_CARDS',
        payload: {
            enemyHand,
            allyHand,
        },
    })
}, [])

const [my, setMy] = useState({})
const [enemy, setEnemy] = useState({})
const [isOtherPlayerTurn, setIsOtherPlayerTurn] = useState(0)
const [enemyCardsInHand, setEnemyCardsInHand] = useState(null)
const [allyCards, setAllyCards] = useState(null)
const [allyFieldHtml, setAllyFieldHtml] = useState(null)
const [enemyFieldHtml, setEnemyFieldHtml] = useState(null)

let areYouTheWinner = (props.gameOver && (
   (playerNumber === 1 && props.winner == 1) || 
   (playerNumber === 2 && props.winner == 2)
))

useEffect(() => {
   console.log('use effect')
   setMy(playerNumber === 1 ? state.game.player1 : state.game.player2)
   setEnemy(playerNumber === 1 ? state.game.player2 : state.game.player1)
   setEnemyCardsInHand(enemy.hand.map(index => (
       <div className="card" key={index + Math.random()}></div>
   )))
   setAllyCards(displayHandCards(my.hand))

   // If turns are equal, it means it's player's 2 turn otherwise it's player's 1 turn
   // If I'm player 1, it will be my turn when turns in the game object are different
   // If I'm player 2, it will be my turn when turns in the game object are the same
   const isOtherPlayerTurn = playerNumber === 1
       ? state.game.player1.turn === state.game.player2.turn
       : state.game.player1.turn !== state.game.player2.turn
   const { _allyFieldHtml, _enemyFieldHtml } = generateFieldCards(
       playerNumber, 
       state.game.player1.field, 
       state.game.player2.field, 
       isOtherPlayerTurn
   )
   setAllyFieldHtml(_allyFieldHtml)
   setEnemyFieldHtml(_enemyFieldHtml)
}, [state.game])

const displayHandCards = handCards => {
   let cards = handCards.length > 0 ? handCards.map(card => {
       <Card
           {...card}
           key={card.id}
           dataId={card.id}
           turnEnded={isOtherPlayerTurn}
           invokeCard={propsCard => invokeCard(propsCard, state.playerNumber === 1 ? state.game.player1 : state.game.player2)}
           toggleAttackMode={propsCard => {
               toggleAttackMode(propsCard)
           }}
       />
   }) : [(<div className="card" key={Math.random()}></div>)]
   return cards
}

// Checked
const generateFieldCards = (playerNumber, player1Field, player2Field, isOtherPlayerTurn) => {
   console.log('generate field cards')
   let allySortedField = Array(FIELD_SIZE).fill(0)
   let enemySortedField = Array(FIELD_SIZE).fill(0)
   let allyFieldHtml = []
   let enemyFieldHtml =[]

   // Sort the array so that cards are positioned in the middle
   if (playerNumber === 1 && player1Field.length > 0) {
       let mid = Math.floor(FIELD_SIZE / 2)
       let sidesSize = 1
       for(let i = 0; i < FIELD_SIZE; i++) {
           // Go mid, then right, if there's item right move left, if there's left move right + 1 and so on
           if (i == 0) {
               allySortedField[mid] = player1Field[i]
           } else if (player1Field[i]) {
               // If there's a card to the right move to the left
               if(allySortedField[mid + sidesSize]) {
                   allySortedField[mid - sidesSize] = player1Field[i]
                   sidesSize++
               } else {
                   allySortedField[mid + sidesSize] = player1Field[i]
               }
           }
       }
   }

   if (player2Field.length > 0) {
       let mid = Math.floor(FIELD_SIZE / 2)
       let sidesSize = 1
       for(let i = 0; i < FIELD_SIZE; i++) {
           if(i == 0) {
               enemySortedField[mid] = player2Field[i]
           } else if(player2Field[i]) {
               // If there's a card to the right move to the left
               if(enemySortedField[mid + sidesSize]) {
                   enemySortedField[mid - sidesSize] = player2Field[i]
                   sidesSize++
               } else {
                   enemySortedField[mid + sidesSize] = player2Field[i]
               }
           }
       }
   }

   // Swap fields if you're player 2
   if (playerNumber == 2) {
       const temp = allySortedField
       allySortedField = enemySortedField
       enemySortedField = temp
   }

   // Populate ally field with ally invoked cards or empty placeholders
   for(let i = 0; i < FIELD_SIZE; i++) {
       allyFieldHtml.push((
           <div className="field-item" key={i + Math.random()}>
               {allySortedField[i] ? <Card
                   dataId={allySortedField[i].id}
                   key={allySortedField[i].id}
                   {...allySortedField[i]}
                   turnEnded={isOtherPlayerTurn}
               /> : ''}
           </div>
       ))
       enemyFieldHtml.push((
           <div className="field-item" key={i + Math.random()} onClick={e => {
               if (props.isAttackMode) props.attackField(e.currentTarget)
           }}>
               {enemySortedField[i] ? <Card
                   dataId={enemySortedField[i].id}
                   key={enemySortedField[i].id}
                   {...enemySortedField[i]}
                   turnEnded={isOtherPlayerTurn}
               /> : ''}
           </div>
       ))
   }

   return { allyFieldHtml, enemyFieldHtml }
}

useEffect(() => {
   setListeners()
   setMy(playerNumber === 1 ? state.game.player1 : state.game.player2)
   setEnemy(playerNumber === 1 ? state.game.player2 : state.game.player1)
}, [state.game])

const setListeners = () => {
   state.socket.on('invoke-player1', card => {
       // Only if the player 2 receives this event is when he should update his field
       if (state.playerNumber === 2) {

       }
   })
}

// Invokes a card into the field and updates ally hand with a new deep copy
const invokeCard = async (card, my) => {
   if (my.field.length >= FIELD_SIZE) {
       return dispatch({
           type: 'SET_ERROR',
           payload: {
               error: 'The field is full'
           }
       })
   }
   if (card.cost > my.energy) {
       return dispatch({
           type: 'SET_ERROR',
           payload: {
               error: "You don't have enough energy"
           }
       })
   }
   let cardsDeepCopy = []
   let allyUpdatedField = my.field.slice(0)
   let invokedCardDeepCopy = Object.assign({}, card)

   invokedCardDeepCopy.isInvoked = true
   allyUpdatedField.push(invokedCardDeepCopy)
   // Update the cards in ally hand by removing the one invoked
   await my.hand.asyncForEach(myCard => {
       // Don't copy the card that has been invoked into ally hand
       if (card.id == myCard.id) return
       cardsDeepCopy.push(Object.assign({}, myCard))
   })

   // Create a copy
   let game = { ...state.game }
   if (playerNumber === 1) {
       game.player1.hand = cardsDeepCopy
       game.player1.life = my.life
       game.player1.field = allyUpdatedField
       game.player1.energy = my.energy - card.cost
   } else {
       game.player2.hand = cardsDeepCopy
       game.player2.life = my.life
       game.player2.field = allyUpdatedField
       game.player2.energy = my.energy - card.cost
   }

   dispatch({
       type: 'SET_GAME',
       payload: {
           game,
       }
   })

   state.socket.emit('update-game', {
       action: playerNumber === 1 ? 'INVOKE_PLAYER1' : 'INVOKE_PLAYER2',
       game,
   })
}

const toggleAttackMode = card => {
   setIsAttackMode(!isAttackMode)
   setAttackingCardId(isAttackMode ? card.id : 0)
}

const attackDirectly = async () => {
   // Find card stats by searching in the field
   let card
   my.field.map(_card => {
       if (_card.id == attackingCardId) {
           return card = _card
       }
   })
   let updatedLife = enemy.life - card.attack
   let allyUpdatedField = []

   my.field.map(_card => {
       if (_card.id == card.id) {
           // Update the attacking card's property canAttack since you can only attack once per turn
           _card.canAttack = false
       }
       allyUpdatedField.push(_card)
   })
   // Create a copy
   let game = { ...state.game }
   if (playerNumber === 1) {
       game.player1.field = allyUpdatedField
       game.player2.life = updatedLife <= 0 ? 0 : updatedLife
   } else {
       game.player2.field = allyUpdatedField
       game.player1.life = updatedLife <= 0 ? 0 : updatedLife
   }
   setIsAttackMode(false)
   setAttackingCardId(0)

   dispatch({
       type: 'SET_GAME',
       payload: {
           game,
       }
   })

   state.socket.emit('update-game', {
       action: playerNumber === 1 ? 'ATTACK_DIRECT_PLAYER1_TO_PLAYER2' : 'ATTACK_DIRECT_PLAYER2_TO_PLAYER1',
       gameId: state.game.gameId,
       game,
   })




   if(updatedLife <= 0) {
       // 2. Turn each card into bytes32 with the desired signature
       let allyBytes32FieldCards = await this.getEncryptedFields()

       // 3. Finish the game by sending the final contract call to close the state channel
       const signedMessage = await this.signMessage(await this.generateHash())
       await this.props.contract.methods.verifyPlayerBalance(
           signedMessage,
           allyBytes32FieldCards,
           this.state.me.life,
           String(this.state.nonce),
           this.state.sequence,
           this.props.account,
       ).send({
           from: this.props.account
       })

       // 4. Show your winning message
       this.setState({
           winner: this.props.isThisPlayerOne ? 1 : 2,
           gameOver: true,
       })

       // 5. Emmit the loss to the other player
       this.emitFinish({
           isThisPlayerOne: this.props.isThisPlayerOne,
       })
   } else {
       // Send a game over event if the ended life is zero after the attack
       this.emitDirectAttack({
           remainingLife: updatedLife,
           isThisPlayerOne: this.props.isThisPlayerOne,
       })
   }
}








// This component manages all the actions and logic as a controller
// export default class GamePage extends Component {
   constructor(props) {
       super(props)
       this.state = {
           me: {
               hand: this.generateInitialCards(true),
               life: GAME_CONFIG.initialLife,
               field: [],
               energy: GAME_CONFIG.initialEnergy,
           },
           enemy: {
               hand: Array(GAME_CONFIG.initialCardsInHand).fill(0),
               life: GAME_CONFIG.initialLife,
               field: [],
               energy: GAME_CONFIG.initialEnergy,
           },
           myLastCardId: 3,
           fieldSize: GAME_CONFIG.maxCardsInField,
           nonce: Math.floor(Math.random() * 1e16),
           sequence: 1,
           error: '',
           isAttackMode: false,
           attackingCardId: 0,
           gameOver: false,
           winner: null,
           turnEnded: this.props.isThisPlayerOne ? true : false,
           socket: '',
           signedMessage: '',
       }
       this.setListeners()
   }

   bytes32(name) {
       return myWeb3.utils.fromAscii(name)
   }

   async getEncryptedFields() {
       let allyBytes32FieldCards = []
       await this.state.me.field.asyncForEach(card => {
           allyBytes32FieldCards.push(this.bytes32(String(card.id)))
           allyBytes32FieldCards.push(this.bytes32(String(card.isInvoked)))
           allyBytes32FieldCards.push(this.bytes32(String(card.canAttack)))
           allyBytes32FieldCards.push(this.bytes32(String(card.cost)))
           allyBytes32FieldCards.push(this.bytes32(String(card.life)))
           allyBytes32FieldCards.push(this.bytes32(String(card.attack)))
           allyBytes32FieldCards.push(this.bytes32(String(card.type)))
       })
       return allyBytes32FieldCards
   }

   // The order for hashing is: playerNonce, cardsCurrentPlayer, playerLife, turn, playerSequence
   async generateHash() {
       let allyBytes32FieldCards = await this.getEncryptedFields()
       // Maybe because enemy's field is empty (?
       const hash = '0x' + abi.soliditySHA3(
           ['uint256', 'bytes32[]', 'uint256', 'uint256'],
           [String(this.state.nonce), allyBytes32FieldCards, String(this.state.me.life), String(this.state.sequence)],
       ).toString('hex')
       return hash
   }

   signMessage(hash) {
       return new Promise((resolve, reject) => {
           myWeb3.eth.personal.sign(hash, this.props.account, (err, result) => {
               if(err) return reject(err)
               resolve(result)
           })
       })
   }

   asyncSetState(state) {
       return new Promise(resolve => {
           this.setState(state, () => resolve())
       })
   }

   emitEventOne(data) {
       const setupEvent = this.props.isThisPlayerOne ? 'one-setup-player-one' : 'one-setup-player-two'
       this.state.socket.emit(setupEvent, data)
   }

   emitInvoke(data) {
       this.state.socket.emit('one-half-invoke', data)
   }

   emitDirectAttack(data) {
       this.state.socket.emit('one-half-attack-directly', data)
   }

   emitFieldAttack(data) {
       this.state.socket.emit('one-half-attack-field', data)
   }

   emitFinish(data) {
       this.state.socket.emit('three-finish', data)
   }

   emitEventTwo(signedMessage) {
       const signEvent = this.props.isThisPlayerOne ? 'two-message-player-one' : 'two-message-player-two'
       const emitData = {
           signedMessage,
           nonce: this.state.nonce,
           allyField: this.state.me.field,
           enemyField: this.state.enemy.field,
           allyLife: this.state.me.life,
           enemyLife: this.state.enemy.life,
           sequence: this.state.sequence,
       }

       this.state.socket.emit(signEvent, emitData)
   }

   emitDrawEnemy(data) {
       this.state.socket.emit('one-half-draw-card', data)
   }

   async setListeners() {
       await this.props.setup()
       await this.asyncSetState({socket: io()})

       // Connect
       this.state.socket.on('connect', () => {
           console.log('Socket id connected to server', this.state.socket.id)
           this.emitEventOne({
               socket: this.state.socket.id,
               address: this.props.account,
               contractAddress: this.props.contractAddress,
               escrow: this.props.isThisPlayerOne ? this.props.escrowPlayerOne : this.props.escrowPlayerTwo,
           })
       })

       // Error
       this.state.socket.on('error', message => {
           console.log('Socket error', message)
       })

       // Invoke
       this.state.socket.on('one-half-enemy-invoke', async message => {
           if((message.isThisPlayerOne && !this.props.isThisPlayerOne) || (!message.isThisPlayerOne && this.props.isThisPlayerOne)) {
               const copyEnemyCards = this.state.enemy.hand.slice(0)
               copyEnemyCards.length--
               const newEnemyField = []

               await message.field.asyncForEach(card => {
                   const cardIdNumber = card.dataId.substr(-1)
                   card.dataId = `ENEMY${cardIdNumber}`
                   card.id = `ENEMY${cardIdNumber}`
                   newEnemyField.push(card)
               })

               this.setState({
                   enemy: {
                       hand: copyEnemyCards,
                       life: this.state.enemy.life,
                       field: newEnemyField,
                       energy: message.energy,
                   }
               })
           }
       })

       // Attack directly
       this.state.socket.on('one-half-receive-attack-directly', async message => {
           if((message.isThisPlayerOne && !this.props.isThisPlayerOne) || (!message.isThisPlayerOne && this.props.isThisPlayerOne)) {
               this.setState({
                   me: {
                       hand: this.state.me.hand,
                       life: message.remainingLife,
                       field: this.state.me.field,
                       energy: this.state.me.energy,
                   },
               })
           }
       })

       // Attack field
       this.state.socket.on('one-half-receive-attack-field', async message => {
           if((message.isThisPlayerOne && !this.props.isThisPlayerOne) || (!message.isThisPlayerOne && this.props.isThisPlayerOne)) {
               let copyAllyField = []
               let copyEnemyField = []

               // 1. Update the receiving card life points
               await this.state.me.field.asyncForEach(card => {
                   let isDead = false
                   if(card.id.substr(-1) == message.victim.id.substr(-1)) {
                       card.life = message.victim.life
                       if(card.life <= 0) isDead = true
                   }
                   if(!isDead) copyAllyField.push(Object.assign({}, card))
               })

               // 2. Update the enemy field
               await this.state.enemy.field.asyncForEach(card => {
                   let isDead = false
                   if(card.id.substr(-1) == message.attacker.id.substr(-1)) {
                       card.life = message.attacker.life
                       if(card.life <= 0) isDead = true
                   }
                   if(!isDead) copyEnemyField.push(Object.assign({}, card))
               })

               // 3. Update fields
               this.setState({
                   me: {
                       hand: this.state.me.hand,
                       life: this.state.me.life,
                       field: copyAllyField,
                       energy: this.state.me.energy,
                   },
                   enemy: {
                       hand: this.state.enemy.hand,
                       life: this.state.enemy.life,
                       field: copyEnemyField,
                       energy: this.state.enemy.energy,
                   },
               })
           }
       })

       this.state.socket.on('one-half-enemy-draw-card', async message => {
           if((message.isThisPlayerOne && !this.props.isThisPlayerOne) || (!message.isThisPlayerOne && this.props.isThisPlayerOne)) {
               let countIncrease = this.state.enemy.hand.length + 1
               this.setState({
                   enemy: {
                       hand: Array(countIncrease).fill(0),
                       life: this.state.enemy.life,
                       field: this.state.enemy.field,
                       energy: this.state.enemy.energy,
                   }
               })
           }
       })

       this.state.socket.on('one-half-next-turn', async message => {
           if(this.props.isThisPlayerOne != message.isThisPlayerOne &&  this.state.turnEnded) {
               // Update hand in the field to allow them to attack if they been there
               let updatedField = []
               await this.state.me.field.asyncForEach(card => {
                   card.canAttack = true
                   updatedField.push(card)
               })
               this.lastEnergy += GAME_CONFIG.energyPerTurn
               this.setState({
                   turnEnded: false,
                   me: {
                       hand: this.state.me.hand,
                       life: this.state.me.life,
                       field: updatedField,
                       energy: this.lastEnergy,
                   }
               })
               if(this.state.me.hand.length < GAME_CONFIG.maxCardsInHand) this.drawCard()
           } else {
               this.lastEnergy += GAME_CONFIG.energyPerTurn
               this.setState({
                   enemy: {
                       hand: this.state.enemy.hand,
                       life: this.state.enemy.life,
                       field: this.state.enemy.field,
                       energy: this.lastEnergy,
                   }
               })
           }
       })

       // Finish the game, if you are not the player sending this message, if
       // you're the receiver basically you lost
       this.state.socket.on('three-finished', async message => {
           if((message.isThisPlayerOne && !this.props.isThisPlayerOne) || (!message.isThisPlayerOne && this.props.isThisPlayerOne)) {
               await this.asyncSetState({
                   me: {
                       hand: this.state.me.hand,
                       life: 0,
                       field: this.state.me.field,
                       energy: this.state.me.energy,
                   },
               })
               // Turn each card into bytes32 with the desired signature
               let allyBytes32FieldCards = await this.getEncryptedFields()

               // Finish the game by sending the final contract call to close the state channel
               const signedMessage = await this.signMessage(await this.generateHash())
               await this.props.contract.methods.verifyPlayerBalance(
                   signedMessage,
                   allyBytes32FieldCards,
                   this.state.me.life,
                   String(this.state.nonce),
                   this.state.sequence,
                   this.props.account,
               ).send({
                   from: this.props.account
               })

               this.setState({
                   gameOver: true,
                   winner: this.props.isThisPlayerOne ? 2 : 1,
               })
           }
       })
   }

   // To set the error state and remove it after 5 seconds
   emitError(msg) {
       setTimeout(() => {
           this.setState({error: ''})
       }, 5e3)
       this.setState({error: msg})
   }

   // Invokes a card into the field and updates ally hand with a new deep copy
   async invokeCard(card) {
       if(this.state.me.field.length >= this.state.fieldSize) {
           return this.emitError('The field is full')
       }
       if(card.cost > this.state.me.energy) {
           return this.emitError("You don't have enough energy")
       }
       let cardsDeepCopy = []
       let allyUpdatedField = this.state.me.field.slice(0)
       let invokedCardDeepCopy = Object.assign({}, card)

       invokedCardDeepCopy.isInvoked = true
       allyUpdatedField.push(invokedCardDeepCopy)
       // Update the hand in ally hand by removing the one invoked
       await this.state.me.hand.asyncForEach(myCard => {
           // Don't copy the card that has been invoked into ally hand
           if(card.id == myCard.id) return
           cardsDeepCopy.push(Object.assign({}, myCard))
       })

       this.setState({
           me: {
               hand: cardsDeepCopy,
               life: this.state.me.life,
               field: allyUpdatedField,
               energy: this.state.me.energy - card.cost,
           }
       }, () => {
           this.emitInvoke({
               isThisPlayerOne: this.props.isThisPlayerOne,
               field: allyUpdatedField,
               energy: this.state.me.energy,
           })
       })
   }

   toggleAttackMode(card) {
       this.setState({
           isAttackMode: !this.state.isAttackMode,
           attackingCardId: !this.state.isAttackMode ? card.id : 0,
       })
   }

   async attackDirectly() {
       // Find card stats by searching in the field
       let card
       await this.state.me.field.asyncForEach(currentCard => {
           if(currentCard.id == this.state.attackingCardId) {
               return card = currentCard
           }
       })
       let updatedLife = this.state.enemy.life - card.attack
       let allyUpdatedField = []

       await this.state.me.field.asyncForEach(currentCard => {
           if(currentCard.id == card.id) {
               // Update the attacking card's property canAttack since you can only attack once per turn
               currentCard.canAttack = false
           }
           allyUpdatedField.push(currentCard)
       })

       // Update enemy's HP or end the game if he lost then we set the state variables
       // gameOver and winner. The winner will be 1 or 2 if you're player one or player 2
       // we know that from the App component because it keeps track of the first player
       // that created the game
       this.setState({
           me: {
               hand: this.state.me.hand,
               life: this.state.me.life,
               field: allyUpdatedField,
               energy: this.state.me.energy,
           },
           enemy: {
               hand: this.state.enemy.hand,
               life: updatedLife <= 0 ? 0 : updatedLife,
               field: this.state.enemy.field,
               energy: this.state.enemy.energy,
           },
           isAttackMode: false,
           attackingCardId: 0,
       })

       if(updatedLife <= 0) {
           // 2. Turn each card into bytes32 with the desired signature
           let allyBytes32FieldCards = await this.getEncryptedFields()

           // 3. Finish the game by sending the final contract call to close the state channel
           const signedMessage = await this.signMessage(await this.generateHash())
           await this.props.contract.methods.verifyPlayerBalance(
               signedMessage,
               allyBytes32FieldCards,
               this.state.me.life,
               String(this.state.nonce),
               this.state.sequence,
               this.props.account,
           ).send({
               from: this.props.account
           })

           // 4. Show your winning message
           this.setState({
               winner: this.props.isThisPlayerOne ? 1 : 2,
               gameOver: true,
           })

           // 5. Emmit the loss to the other player
           this.emitFinish({
               isThisPlayerOne: this.props.isThisPlayerOne,
           })
       } else {
           // Send a game over event if the ended life is zero after the attack
           this.emitDirectAttack({
               remainingLife: updatedLife,
               isThisPlayerOne: this.props.isThisPlayerOne,
           })
       }
   }

   getDamageMultiplier(attackerType, victimType) {
       // this.globalCardTypes = ['fire', 'water', 'wind', 'life', 'death', 'neutral']
       let damageMultiplier = 1
       switch(attackerType) {
           case 'fire':
               if(victimType == 'wind') damageMultiplier = 2
               else if(victimType == 'water' || victimType == 'life' || victimType == 'death') damageMultiplier = 0.5
               break
           case 'wind':
               if(victimType == 'water') damageMultiplier = 2
               else if(victimType == 'fire' || victimType == 'life' || victimType == 'death') damageMultiplier = 0.5
               break
           case 'water':
               if(victimType == 'fire') damageMultiplier = 2
               else if(victimType == 'wind' || victimType == 'life' || victimType == 'death') damageMultiplier = 0.5
               break
           case 'life':
               if(victimType == 'fire' || victimType == 'wind' || victimType == 'water' || victimType == 'neutral') damageMultiplier = 2
               break
           case 'death':
               if(victimType == 'fire' || victimType == 'wind' || victimType == 'water' || victimType == 'neutral') damageMultiplier = 2
               break
           case 'neutral':
               if(victimType == 'fire' || victimType == 'wind' || victimType == 'water' || victimType == 'life' || victimType == 'death') damageMultiplier = 0.5
               break
       }
       return damageMultiplier
   }

   async attackField(target) {
       // Find card stats by searching in the field
       let victim = null
       let attacker = {}
       let allyUpdatedField = []
       let enemyUpdatedField = []

       await this.state.enemy.field.asyncForEach(currentCard => {
           if(currentCard.id == target.firstChild.dataset.id) {
               victim = currentCard
           }
       })

       if(!victim) return this.toggleAttackMode()

       await this.state.me.field.asyncForEach(currentCard => {
           if(currentCard.id == this.state.attackingCardId) {
               attacker = currentCard
           }
       })

       let attackingDamageMultiplier = this.getDamageMultiplier(attacker.type, victim.type)
       let victimDamageMultiplier = this.getDamageMultiplier(victim.type, attacker.type)

       // Reduce attacker's and receiver's card life
       victim.life = victim.life - attacker.attack * attackingDamageMultiplier
       attacker.life = attacker.life - victim.attack * victimDamageMultiplier
       attacker.canAttack = false

       // Update the field by deleting the destroyed cards, we don't care bout those, they are gone forever
       await this.state.enemy.field.asyncForEach(currentCard => {
           let addCard = true
           if(currentCard.id == target.firstChild.dataset.id) {
               if(victim.life <= 0) addCard = false
           }
           if(addCard) enemyUpdatedField.push(Object.assign({}, currentCard))
       })
       await this.state.me.field.asyncForEach(currentCard => {
           let addCard = true
           if(currentCard.id == this.state.attackingCardId) {
               if(attacker.life <= 0) addCard = false
           }
           if(addCard) allyUpdatedField.push(Object.assign({}, currentCard))
       })

       this.setState({
           me: {
               hand: this.state.me.hand,
               life: this.state.me.life,
               field: allyUpdatedField,
               energy: this.state.me.energy,
           },
           enemy: {
               hand: this.state.enemy.hand,
               life: this.state.enemy.life,
               field: enemyUpdatedField,
               energy: this.state.enemy.energy,
           },
           isAttackMode: false,
           attackingCardId: 0,
       })

       this.emitFieldAttack({
           isThisPlayerOne: this.props.isThisPlayerOne,
           attacker,
           victim,
       })
   }

   async endTurn() {
       const signedMessage = await this.signMessage(await this.generateHash())
       await this.asyncSetState({
           turnEnded: true,
           sequence: ++this.state.sequence,
           nonce: Math.floor(Math.random() * 1e16),
           signedMessage,
       })
       this.emitEventTwo(signedMessage)
   }

   async drawCard() {
       let life = this.randomRange(this.globalMinLife, this.globalMaxLife)
       let attack = this.randomRange(this.globalMinAttack, this.globalMaxAttack)
       let type = this.globalCardTypes[this.randomRange(0, this.globalCardTypes.length - 1)]
       let addAttackPoints = 0
       let addLifePoints = (life % 10 / 2)
       if(attack >= 10) addAttackPoints = 5
       else if(attack > 5) addAttackPoints = attack % 5
       let cost = 1 + addLifePoints + addAttackPoints
       let myLastCardId = this.state.myLastCardId + 1

       let card = {
           id: `ALLY${myLastCardId}`,
           isInvoked: false,
           canAttack: false,
           cost,
           life,
           attack,
           type
       }

       let updatedHand = this.state.me.hand.slice(0)
       updatedHand.push(card)

       this.setState({
           me: {
               hand: updatedHand,
               life: this.state.me.life,
               field: this.state.me.field,
               energy: this.state.me.energy,
           },
           myLastCardId,
       })

       this.emitDrawEnemy({
           isThisPlayerOne: this.props.isThisPlayerOne,
       })
   }

   // We pass the entire state to the view
   render() {
       return (
           <GameView
               {...this.state}
               isThisPlayerOne={this.props.isThisPlayerOne}
               invokeCard={card => this.invokeCard(card)}
               toggleAttackMode={card => this.toggleAttackMode(card)}
               attackDirectly={() => this.attackDirectly()}
               attackField={target => this.attackField(target)}
               endTurn={() => this.endTurn()}
           />
       )
   }
// }